HTML5 has some elements that identify different content areas. 
These elements make your HTML easier to read and help with Search
Engine Optimization (SEO) and accessibility. Identify the main 
section of this page by adding a <main> opening tag before the 
h1 element, and a </main> closing tag after the p element.

HTML attributes are special words used inside the opening tag of an 
element to control the element's behavior.

Before adding any new content, you should make use of a section 
element to separate the cat photos content from the future content.

When you add a lower rank heading element to the page, it's 
implied that you're starting a new subsection.

The figure element represents self-contained content and will 
allow you to associate an image with a caption.

A figure caption (figcaption) element is used to add a caption to 
describe the image contained within the figure element. For 
example, <figcaption>A cute cat</figcaption> adds the caption A 
cute cat.

Now you will add a web form to collect information from users. 
Add a form element.

The action attribute indicates where form data should be sent. 
For example, <form action="/submit-url"></form> tells the browser 
that the form data should be sent to the path /submit-url.

The input element allows you several ways to collect data from a 
web form. Like img elements, input elements are self-closing and 
do not need closing tags. Nest an input element in the form element.

There are many kinds of inputs you can create using the type 
attribute. You can easily create a password field, reset button, 
or a control to let users select a file from their computer. 
Create a text field to get text input from a user by adding the 
type attribute with the value text to the input element.

In order for a form's data to be accessed by the location specified 
in the action attribute, you must give the text field a name 
attribute and assign it a value to represent the data being 
submitted. For example, you could use the following syntax for an 
email address text field: <input type="text" name="email">.

Placeholder text is used to give people a hint about what kind of 
information to enter into an input. For example, 
<input type="text" placeholder="Email address">.

To prevent a user from submitting your form when required 
information is missing, you need to add the required attribute to 
an input element. There's no need to set a value to the required 
attribute. Instead, just add the word required to the input 
element, making sure there is space between it and other 
attributes.

Even though you added your button below the text input, they 
appear next to each other on the page. That's because both input 
and button elements are inline elements, which don't appear on 
new lines. The button you added will submit the form by default. 
However, relying on default behavior may cause confusion. Add the 
type attribute with the value submit to the button to make it 
clear that it is a submit button.

You can use radio buttons for questions where you want only one 
answer out of multiple options. Here is an example of a radio 
button with the option of cat: <input type="radio"> cat. Remember 
that input elements are self-closing.
<input type="radio"/>Indoor

label elements are used to help associate the text for an input 
element with the input element itself (especially for assistive 
technologies like screen readers). For example, 
<label><input type="radio"> cat</label> makes it so clicking the 
word cat also selects the corresponding radio button.
<label><input type="radio"> Indoor</label>

Notice that both radio buttons can be selected at the same time. 
To make it so selecting one radio button automatically deselects 
the other, both buttons must have a name attribute with the same 
value. Add the name attribute with the value indoor-outdoor to 
both radio buttons.

If you select the Indoor radio button and submit the form, the 
form data for the button is based on its name and value attributes. 
Since your radio buttons do not have a value attribute, the form 
data will include indoor-outdoor=on, which is not useful when you 
have multiple buttons.Add a value attribute to both radio buttons. 
For convenience, set the button's value attribute to the same 
value as its id attribute.

The fieldset element is used to group related inputs and labels 
together in a web form. fieldset elements are block-level elements, 
meaning that they appear on a new line. Nest the Indoor and 
Outdoor radio buttons within a fieldset element, and don't forget 
to indent the radio buttons.

The legend element acts as a caption for the content in the 
fieldset element. It gives users context about what they should 
enter into that part of the form. Add a legend element with the 
text Is your cat an indoor or outdoor cat? above both of the radio 
buttons.

Syntax for CheckBox input.
<input id="loving" type="checkbox"> Loving

There's another way to associate an input element's text with the 
element itself. You can nest the text within a label element and 
add a for attribute with the same value as the input element's id 
attribute.
<input id="loving" type="checkbox"> <label for="loving">Loving</label>

Like radio buttons, form data for selected checkboxes are 
name / value attribute pairs. While the value attribute is optional, 
it's best practice to include it with any checkboxes or radio 
buttons on the page.

You can set browser behavior by adding self-closing meta elements 
in the head. Here's an example:
<meta attribute="value">
Tell the browser to parse the markup into multiple languages by 
creating a meta element as a child of the head element. Set its 
charset attribute to UTF-8.

For the styling of the page to look similar on mobile as it does 
on a desktop or laptop, you need to add a meta element with a 
special content attribute.
Add the following within the head element:
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

Next, you want to center the div horizontally. You can do this by setting its 
margin-left and margin-right properties to auto. Think of the margin as 
invisible space around an element. Using these two margin properties, center 
the div element within the body element.

Since the cafe's main product for sale is coffee, you could use an image of 
coffee beans for the background of the page. Add a background-image property and set its value to 
url(https://cdn.freecodecamp.org/curriculum/css-cafe/beans.jpg).

If you make the width of the page preview smaller, you will notice at some 
point, some of the text on the left starts wrapping around to the next line. 
This is because the width of the p elements on the left side can only take up 
50% of the space. Since you know the prices on the right have significantly 
fewer characters, change the flavor class width value to be 75% and the price 
class width value to be 25%.


The current width of the menu will always take up 80% of the body element's 
width. On a very wide screen, the coffee and dessert appear far apart from 
their prices. Add a max-width property to the menu class with a value of 500px
to prevent it from growing too wide.

You can add a fallback value for the font-family by adding another font name 
separated by a comma. Fallbacks are used in instances where the initial is 
not found/available. Add the fallback font serif after the Impact font.


When the shorthand margin property has two values, it sets margin-top and 
margin-bottom to the first value, and margin-left and margin-right to the 
second value.

#----------------------------------------------------------------------------------------------


COLOR THEORY
Notice that the red and cyan colors are very bright right next to each other. 
This contrast can be distracting if it's overused on a website, and can make 
text hard to read if it's placed on a complementary-colored background. It's 
better practice to choose one color as the dominant color, and use its 
complementary color as an accent to bring attention to certain content on the 
page.

Notice how your eyes are naturally drawn to the red color in the center? When 
designing a site, you can use this effect to draw attention to important 
headings, buttons, or links. There are several other important color  combinations 
outside of complementary colors, but you'll learn those a bit later.

The CSS hsl function accepts 3 values: a number from 0 to 360 for hue, a 
percentage from 0 to 100 for saturation, and a percentage from 0 to 100 for 
lightness. If you imagine a color wheel, the hue red is at 0 degrees, green 
is at 120 degrees, and blue is at 240 degrees. Saturation is the intensity of 
a color from 0%, or gray, to 100% for pure color. Lightness is how bright a 
color appears, from 0%, or complete black, to 100%, complete white, with 50% 
being neutral.

A gradient is when one color transitions into another. The CSS linear-gradient 
function lets you control the direction of the transition along a line, and 
which colors are used. One thing to remember is that the linear-gradient 
function actually creates an image element, and is usually paired with the 
background property which can accept an image as a value.
background: linear-gradient(90deg, rgb(255, 0, 0), rgb(0, 255, 0));


Color-stops allow you to fine-tune where colors are placed along the gradient 
line. They are a length unit like px or percentages that follow a color in the 
linear-gradient function. For example, in this red-black gradient, the 
transition from red to black takes place at the 90% point along the gradient 
line, so red takes up most of the available space:
linear-gradient(90deg, red 90%, black)50%;


Even without the color-stops, you might have noticed that the colors for the 
green marker transition at the same points as the red marker. The first color 
is at the start (0%), the second is in the middle (50%), and the last is at 
the end (100%) of the gradient line. The linear-gradient function automatically 
calculates these values for you, and places colors evenly along the gradient 
line by default.


If no gradientDirection argument is provided to the linear-gradient function, 
it arranges colors from top to bottom, or along a 180 degree line, by default.

With the CSS opacity property, you can control how opaque or transparent an 
element is. With the value 0, or 0%, the element will be completely 
transparent, and at 1.0, or 100%, the element will be completely opaque like 
it is by default.

Another way to set the opacity for an element is with the alpha channel. 
Similar to the opacity property, the alpha channel controls how transparent or 
opaque a color is. You've already set sleeve's opacity with a named color and 
the opacity property, but you can add an alpha channel to the other CSS color 
properties.

#----------------------------------------------------------------------------------------------
HTML FORMS

The vh unit stands for viewport height, and is relative to 1% of the height of 
the viewport.

The method attribute specifies how to send form-data to the URL specified in 
the action attribute. The form-data can be sent via a GET request as URL 
parameters (with method="get") or via a POST request as data in the request 
body (with method="post").

The rem unit stands for root em, and is relative to the font size of the html 
element.

Following accessibility best practices, link the input elements and the label 
elements together using the for attribute.

Specifying the type attribute of a form element is important for the browser 
to know what kind of data it should expect. If the type is not specified, the 
browser will default to text.

Give the first two input elements a type attribute of text, the third a type 
attribute of email, and the fourth a type attribute of password.

The email type only allows emails with a @ and a . in the domain. The password 
type obscures the input, and warns if the site does not use HTTPS.

The first input element with a type of submit is automatically set to submit 
its nearest parent form element.

To handle the form submission, after the last fieldset element add an input 
element with the type attribute set to submit and the value attribute set to 
Submit.

Certain type attribute values come with built-in form validation. For example, 
type="email" requires that the value be a valid email address.

Add custom validation to the password input element, by adding a minlength 
attribute with a value of 8. Doing so prevents inputs of less than 8 characters 
being submitted.

With type="password" you can use the pattern attribute to define a regular 
expression that the password must match to be considered valid. Add a pattern 
attribute to the password input element to require the input match: [a-z0-5]{8,} 
The above is a regular expression which matches eight or more lowercase letters 
or the digits 0 to 5. Then, remove the minlength attribute, and try it out.

Moving on to the final fieldset. What if you wanted to allow a user to upload 
a profile picture? Well, the input type file allows just that

Add another label after the first, with the text Input your age (years): . Then, 
nest an input with the type of number.

Next, add a min attribute to the input with a value of 13 because users under 
the age of 13 should not register. Also, users probably will not be over the 
age of 120; add a max attribute with a value of 120.

Submitting the form with an option selected would not send a useful value to 
the server. As such, each option needs to be given a value attribute. Without 
which, the text content of the option will be submitted to the server.

Give the first option a value of "", and the subsequent option elements value 
attributes from 1 to 4.

The textarea appears too small. To give it an initial size, you can add the rows 
and cols attributes. Add an initial size of 3 rows and 30 columns.

The border of the last fieldset element looks a little out of place. You can 
select the last element of a specific type using the last-of-type CSS pseudo-class, 

ATTRIBUTE SELECTOR
To style the submit button, you can use an attribute selector, which selects an element based on the given attribute value. Here is an example:
input[name="password"]
The above selects input elements with a name attribute value of password.
Now, use the attribute selector to style the submit button with a display of block, and a width of 60%.

In the CSS box model, every HTML element is treated as a box with four areas.
Imagine you receive a box from your favorite online retailer -- the content is the item in the box, or in our case, a header, paragraph, or image element.
The content is surrounded by a space called padding, similar to how bubble wrap separates an item from the box around it.
Think of the border like the cardboard box your item was shipped in.

Adding 1 pixel of padding to the top, bottom, left, and right of the canvas changed its dimensions to 502 pixels x 602 pixels.
Replace the padding property with overflow set to hidden - changing the canvas back to its original dimensions.

Use the filter property to blur the painting by 2px in the .canvas element.

The rectangles are too small and their edges don't have the soft quality of a painting.
Increase the area and soften the edges of .one by setting its box-shadow to 0 0 3px 3px #efb762.

Rotate each rectangle to give them more of an imperfect, hand-painted look.
Use the transform property on the .one selector to rotate it counter clockwise by 0.6 degrees.
You should set the transform property to rotate(-0.6deg).


 <meta name="viewport" content="wdith=device-width, initial-scale=1"/>
 <meta charset="UTF-8"/>

 The flex-wrap property determines how your flex items behave when the flex container is too small. Setting it to wrap will allow the items to wrap to the next row or column. nowrap (default) will prevent your items from wrapping and shrink them if needed.

 Notice how some of your images have become distorted. This is because the images have different aspect ratios. Rather than setting each aspect ratio individually, you can use the object-fit property to determine how images should behave.

Give your .gallery img selector the object-fit property and set it to cover. This will tell the image to fill the img container while maintaining aspect ratio, resulting in cropping to fit.

The ::after pseudo-element creates an element that is the last child of the selected element. You can use it to add an empty element after the last image. If you give it the same width as the images it will push the last image to the left when the gallery is in a two-column layout. Right now, it is in the center because you set justify-content: center on the flex container.

Remember that fonts with spaces in the name must be wrapped in quotes for CSS.

The letter-spacing property can be used to adjust the space between each character of text in an element.

Horizontal spacing between equally important elements can increase the readability of your text.
Wrap the text 2/3 cup (55g) in a span element.

The :not pseudo-selector can be used to select all elements that do not match the given CSS rule.
div:not(#example) {
  color: red;
}
The above selects all div elements without an id of example.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ACCESSIBILITY and SEO
The charset attribute specifies the character encoding of the page, and, nowadays, UTF-8 is the only encoding supported by most browsers.

Continuing with the meta elements, a viewport definition tells the browser how to render the page. Including one betters visual accessibility on mobile, and improves SEO (search engine optimization).
Add a viewport definition with a content attribute detailing the width and initial-scale of the page.

Another important meta element for accessibility and SEO is the description definition. The value of the content attribute is used by search engines to provide a description of your page.

Add a meta element with the name attribute set to description, and give it a useful content attribute.

 <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="freeCodeCamp Accessibility Quiz practice project" />
    <title>HTML CSS Quiz</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

Navigation is a core part of accessibility, and screen readers rely on you to provide the structure of your page. This is accomplished with semantic HTML elements.
Add a header and a main element to your page.
The header element will be used to introduce the page, as well as provide a navigation menu.
The main element will contain the core content of your page.

Within the header, provide context about the page by nesting one img, h1, and nav element.
The img should point to https://cdn.freecodecamp.org/platform/universal/fcc_primary.svg, and have an id of logo.
The h1 should contain the text HTML/CSS Quiz.

A useful property of an SVG (scalable vector graphics) is that it contains a path attribute which allows the image to be scaled without affecting the resolution of the resultant image.
Currently, the img is assuming its default size, which is too large. Correctly, scale the image using it's id as a selector, and setting the width to max(100px, 18vw).

As described in the freeCodeCamp Style Guide, the logo should retain an aspect ratio of 35 / 4, and have padding around the text.

First, change the background-color to #0a0a23 so you can see the logo. Then, use the aspect-ratio property to set the desired aspect ratio to 35 / 4. Finally, add a padding of 0.4rem all around.

nav>ul {
  display: flex;
  justify-content: space-evenly;
}

<form method="post" action="https://freecodecamp.org/practice-project/accessibility-quiz">

To increase the page accessibility, the role attribute can be used to indicate the purpose behind an element on the page to assistive technologies. The role attribute is a part of the Web Accessibility Initiative (WAI), and accepts preset values.
Give each of the section elements the region role.

Every region role requires a label, which helps screen reader users understand the purpose of the region. One method for adding a label is to add a heading element inside the region and then reference it with the aria-labelledby attribute.

Add the following aria-labelledby attributes to the section elements:
student-info
html-questions
css-questions
Then, within each section element, nest one h2 element with an id matching the corresponding aria-labelledby attribute. Give each h2 suitable text content.

<li><a href="#student-info">INFO</a></li>
<li><a href="#html-questions">HTML</a></li>
<li><a href="#css-questions">CSS</a></li>

It is important to link each input to the corresponding label element. This provides assistive technology users with a visual reference to the input.
This is done by giving the label a for attribute, which contains the id of the input.
This section will take a student's name, email address, and date of birth. Give the label elements appropriate for attributes, as well as text content. Then, link the input elements to the corresponding label elements.

Even though you added a placeholder to the first input element in the previous lesson, this is actually not a best-practice for accessibility; too often, users confuse the placeholder text with an actual input value - they think there is already a value in the input.

Remove the placeholder text from the first input element, relying on the label being the best-practice.

Arguably, D.O.B. is not descriptive enough. This is especially true for visually impaired users. One way to get around such an issue, without having to add visible text to the label, is to add text only a screen reader can read.

Append a span element with a class of sr-only to the current text content of the third label element.

Arguably, D.O.B. is not descriptive enough. This is especially true for visually impaired users. One way to get around such an issue, without having to add visible text to the label, is to add text only a screen reader can read.

Append a span element with a class of sr-only to the current text content of the third label element.
Within the span element, add the text (Date of Birth).

The .sr-only text is still visible. There is a common pattern to visually hide text for only screen readers to read.
This pattern is to set the following CSS properties:
position: absolute;
width: 1px;
height: 1px;
padding: 0;
margin: -1px;
overflow: hidden;
clip: rect(0, 0, 0, 0);
white-space: nowrap;
border: 0;
Use the above to define the sr-only class.

Although not required for label elements with a nested input, it is still best-practice to explicitly link a label with its corresponding input element.

Now, add a for attribute to each of your four labels that links the label to its corresponding radio input.

Two final semantic HTML elements for this project are the footer and address elements. The footer element is a container for a collection of content that is related to the page, and the address element is a container for contact information for the author of the page.

After the main element, add one footer element, and nest one address element within it.

Clicking on the navigation links should jump the viewport to the relevant section. However, this jumping can be disorienting for some users.

Select all elements, and set the scroll-behavior to smooth.

Wrap the style rule that sets scroll-behavior: smooth within an @media at-rule with the media feature prefers-reduced-motion having no-preference set as the value.
@media(prefers-reduced-motion: no-preference) {
   * {
  scroll-behavior: smooth;
}
} 

Finally, the navigation accessibility can be improved by providing keyboard shortcuts.

The accesskey attribute accepts a space-separated list of access keys. For example:
<button type="submit" accesskey="s">Submit</button>
Give each of the navigation links a single-letter access key.
Note: It is not always advised to use access keys, but they can be useful
Well done. You have completed the Accessibility Quiz practice project.





Screen readers announce HTML elements based on the document flow. We will eventually want the balance sheet to have a heading of "Balance Sheet" and a subheading of "AcmeWidgetCorp". However, this order does not make sense if announced by a screen reader.
Give your existing span the class attribute set to flex, and add two span elements within it. Give the first the text AcmeWidgetCorp. Give the second the text Balance Sheet. You will use CSS to reverse the order of the text on the page, but the HTML order will make more sense for a screen reader.

Below your h1 element, create a div element. Give it an id attribute set to years. You want this particular element to be hidden from screen readers, so give it the aria-hidden attribute set to true.

add three table elements. You will be using CSS to style these into a single table, but using separate tables will help screen readers understand the document flow.

HTML tables use the caption element to describe what the table is about. The caption element should always be the first child of a table, but can be positioned with the caption-side CSS property.

The thead and tbody elements are used to indicate which portion of your table is the header, and which portion contains the primary data or content.

The tr element is used to indicate a table row. Add a tr element within your thead element. In your new tr element, add a td element, followed by three th elements.
The td element indicates a data cell, while the th element indicates a header cell.

Leave the td element empty. This element exists only to ensure your table has a four-column layout and associate the headers with the correct columns.

Before you get too far into your styling, you should make use of the sr-only class. You can use CSS to make elements with this class completely hidden from the visual page, but still be announced by screen readers.
The CSS you are about to write is a common set of properties used to ensure elements are completely hidden visually.
The span[class~="sr-only"] selector will select any span element whose class includes sr-only. Create that selector, and give it a border property set to 0.
The CSS clip property is used to define the visible portions of an element. Set the span[class~="sr-only"] selector to have a clip property of rect(1px, 1px, 1px, 1px).
The clip-path property determines the shape the clip property should take. Set both the clip-path and -webkit-clip-path properties to the value of inset(50%), forming the clip-path into a rectangle within the element.
Now you need to size these elements down. Give your span[class~="sr-only"] selector a width and height property set to 1px.
Finally, you need to take these hidden elements out of the document flow. Give the span[class~="sr-only"] selector a position property set to absolute, a padding property set to 0, and a margin property set to -1px. This will ensure that not only are they no longer visible, but they are not even within the page view.
To prevent the text content from overflowing, give your span[class~="sr-only"] selector an overflow property set to hidden and a white-space property set to nowrap.
Finally, you need to take these hidden elements out of the document flow. Give the span[class~="sr-only"] selector a position property set to absolute, a padding property set to 0, and a margin property set to -1px. This will ensure that not only are they no longer visible, but they are not even within the page view.
span[class~="sr-only"] {
  border: 0;
  clip: rect(1px, 1px, 1px, 1px);
  clip-path: inset(50%);
  -webkit-clip-path: inset(50%);
  height: 1px;
  width: 1px;
  overflow: hidden;
  white-space: nowrap;
  position: absolute;
  padding: 0;
  margin: -1px;
}

The :first-of-type pseudo-selector is used to target the first element that matches the selector. Create an h1 .flex span:first-of-type selector to target the first span element in your .flex container. Remember that your span elements are reversed, visually, so this will appear to be the second element on the page.
Give your new selector a font-size property of 0.7em to make it look like a sub-heading.
The :last-of-type pseudo-selector does the exact opposite - it targets the last element that matches the selector.

position: sticky;

The calc() function is a CSS function that allows you to calculate a value based on other values. For example, you can use it to calculate the width of the viewport minus the margin of an element:
.example {
  margin: 10px;
  width: calc(100% - 20px);
}

Style the text within your #years element by creating a #years span[class] selector. The span[class] syntax will target any span element that has a class attribute set, regardless of the attribute's value.

Before you start diving in to the table itself, your span elements are currently bolded. Create a span:not(.sr-only) selector and give it a font-weight property set to normal.

The :not() pseudo-selector is used to target all elements that do not match the selector - in this case, any of your span elements that do not have the sr-only class. This ensures that your earlier rules for the span[class~="sr-only"] selector are not overwritten.

Create a table selector to target your tables. Set the border-collapse property to collapse, which will allow cell borders to collapse into a single border, instead of a border around each cell

The [attribute="value"] selector targets any element that has an attribute with a specific value. Create a tr[class="total"] selector to target specifically your tr elements with the total

The :nth-of-type() pseudo-selector is used to target specific elements based on their order among siblings of the same type

FontAwesome is a library of SVG-powered icons, many of which are freely available to use. You will be using some of these icons in this project, so you will need to link the external stylesheet to your HTML.

Add a link element with a rel of stylesheet and an href of https://use.fontawesome.com/releases/v5.8.2/css/all.css.

Typically, HTML is rendered in a top-down manner. Elements at the top of the code are positioned at the top of the page. However, many times you may want to move the elements to different positions. You can do this with the position property.
Set the position property for the #back-wall element to absolute. An absolute position takes the element out of that top-down document flow and allows you to adjust it relative to its container.
When an element is manually positioned, you can shift its layout with top, left, right, and bottom. 

The z-index property is used to create "layers" for your HTML elements. If you are familiar with image editing tools, you may have worked with layers before. This is a similar concept.
Elements with a higher z-index value will appear to be layered on top of elements with a lower z-index value. This can be combined with the positioning in the previous lesson to create unique effects.

The i element is used for idiomatic text, or text that is separate from the "normal" text content. This could be for italic text, such as scientific terms, or for icons like those provided by FontAwesome.
Within your #white-paper element, add four i elements. Give them all a class value of fas fa-music.
This special class is how FontAwesome determines which icon to load. fas indicates the category of icons (FontAwesome Solid, here), while fa-music selects the specific icon.

The @media at-rule, also known as a media query, is used to conditionally apply CSS. Media queries are commonly used to apply CSS based on the viewport width using the max-width and min-width properties.
In the below example the padding is applied to the .card class when the viewport is 960px wide and below.
@media (max-width: 960px) {
  .card {
    padding: 2rem;
  }
}

You might have noticed the keys collapse when the browser window is smaller than 768px. Set overflow to hidden in the first .keys selector, to take care of this issue. This property will hide any element that is pushed outside the set width value of .keys.

Logical operators can be used to construct more complex media queries. The and logical operator is used to query two media conditions.
For example, a media query that targets a display width between 500px and 1000px would be:
@media (min-width: 500px) and (max-width: 1000px){
}

You can see the body (it's the inner-most box on your page); the box around it is the html element. Make your body fill the whole viewport by giving it a height of 100vh. Remove the default margin from the body by setting the margin to 0. Finally, set the overflow property to hidden to hide any scroll bars that appear when something extends past the viewport.

Now you have something that is resembling a building. You are ready to create your first variable. Variable declarations begin with two dashes (-) and are given a name and a value like this: --variable-name: value;. In the rule for the bb1 class, create a variable named --building-color1 and give it a value of #999.

To use a variable, put the variable name in parentheses with var in front of them like this: var(--variable-name). Whatever value you gave the variable will be applied to whatever property you use it on.
Add the variable --building-color1 you created in the previous step as the value of the background-color property of the .bb1a class.

That didn't work. You should add a fallback value to a variable by putting it as the second value of where you use the variable like this: var(--variable-name, fallback-value). The property will use the fallback value when there's a problem with the variable. Add a fallback value of green to the background-color of .bb2.

That didn't work, because the variables you declared in .bb1 do not cascade to the .bb2 and .bb3 sibling elements. That's just how CSS works. Because of this, variables are often declared in the :root selector. This is the highest level selector in CSS; putting your variables there will make them usable everywhere. Add the :root selector to the top of your stylesheet, and move all your variable declarations there.

Gradients in CSS are a way to transition between colors across the distance of an element. They are applied to the background property and the syntax looks like this:
gradient-type(
  color1,
  color2
);
In the example, color1 is solid at the top, color2 is solid at the bottom, and in between it transitions evenly from one to the next. 


You can specify where you want a gradient transition to complete by adding it to the color like this:
gradient-type(
  color1,
  color2 20%,
  color3
);

You can see the hard color change at the top of the section. Change the gradient type from linear-gradient to repeating-linear-gradient for this section. This will make the four colors of your gradient repeat until it gets to the bottom of the element; giving you some stripes, and saving you from having to add a bunch of elements to create them.

So far, all the gradients you created have gone from top to bottom, that's the default direction. You can specify another direction by adding it before your colors like this:
gradient-type(
  direction,
  color1,
  color2
);


You can add multiple gradients to an element by separating them with a comma (,) like this:
gradient1(
  colors
),
gradient2(
  colors
);

At the top of the sky gradient color list, where you would put a direction for the gradient; add circle closest-corner at 15% 15%,. This will move the start of the gradient to 15% from the top and left. It will make it end at the closest-corner and it will maintain a circle shape. These are some keywords built into gradients to describe how it behaves.

The loading attribute on an img element can be set to lazy to tell the browser not to fetch the image resource until it is needed (as in, when the user scrolls the image into view). As an additional benefit, lazy loaded elements will not load until the non-lazy elements are loaded - this means users with slow internet connections can view the content of your page without having to wait for the images to load.
Give your new img element a loading attribute set to lazy.

The Referer HTTP header contains information about the address or URL of a page that a user might be visiting from. This information can be used in analytics to track how many users from your page visit freecodecamp.org, for example. Setting the rel attribute to noreferrer omits this information from the HTTP request. Give your a element a rel attribute set to noreferrer

Use the minmax function to make your columns responsive on any device. The minmax function takes two arguments, the first being the minimum value and the second being the maximum. These values could be a length, percentage, fr, or even a keyword like max-content.

Your magazine will have three primary sections. You already set the overall layout in the main rule, but you can adjust the placement in the child rules.
One option is the grid-column property, which is shorthand for grid-column-start and grid-column-end. The grid-column property tells the grid item which grid line to start and end at.

The CSS repeat() function is used to repeat a value, rather than writing it out manually, and is helpful for grid layouts. For example, setting the grid-template-columns property to repeat(20, 200px) would create 20 columns each 200px wide.

he object-fit property tells the browser how to position the element within its container. In this case, cover will set the image to fill the container, cropping as needed to avoid changing the aspect ratio.

If you wanted to add more social icons, but keep them on the same row, you would need to update grid-template-columns to create additional columns. As an alternative, you can use the grid-auto-flow property.
This property takes either row or column as the first value, with an optional second value of dense. grid-auto-flow uses an auto-placement algorithm to adjust the grid layout. Setting it to column will tell the algorithm to create new columns for content as needed. The dense value allows the algorithm to backtrack and fill holes in the grid with smaller items, which can result in items appearing out of order.

Now the auto-placement algorithm will kick in when you add a new icon element. However, the algorithm defaults the new column width to be auto, which will not match your current columns.
You can override this with the grid-auto-columns property. Give the .social-icons selector a grid-auto-columns property set to 1fr

Your .text element is not a CSS Grid, but you can create columns within an element without using Grid by using the column-width property.
Give your .text selector a column-width property set to 25rem.

The gap property is a shorthand way to set the value of column-gap and row-gap at the same time. If given one value, it sets the column-gap and row-gap both to that value. If given two values, it sets the row-gap to the first value and the column-gap to the second.

The place-items property can be used to set the align-items and justify-items values at the same time. The place-items property takes one or two values. If one value is provided, it is used for both the align-items and justify-items properties. If two values are provided, the first value is used for the align-items property and the second value is used for the justify-items property.


#ANIMATIONS
The transform-origin property is used to set the point around which a CSS transformation is applied. For example, when performing a rotate (which you will do later in this project), the transform-origin determines around which point the element is rotated.
Give the .line selector a transform-origin property of 0% 0%. This will offset the origin point by 0% from the left and 0% from the top, setting it to the top left corner of the element.
Remember that the transform property allows you to manipulate the shape of an element
In this case, using the rotate(60deg) value will rotate the element around its transform-origin point by 60 degrees clockwise.


The @keyframes at-rule is used to define the flow of a CSS animation. Within the @keyframes rule, you can create selectors for specific points in the animation sequence, such as 0% or 25%, or use from and to to define the start and end of the sequence.
@keyframes rules require a name to be assigned to them, which you use in other rules to reference. For example, the @keyframes freeCodeCamp { } rule would be named freeCodeCamp.

You now need to define how your animation should start. To do this, create a 0% rule within your @keyframes wheel rule. The properties you set in this nested selector will apply at the beginning of your animation.
As an example, this would be a 12% rule:
@keyframes freecodecamp {
  12% {
    color: green;
  }
}

The animation-name property is used to link a @keyframes rule to a CSS selector. The value of this property should match the name of the @keyframes rule. Give your .wheel selector an animation-name property set to wheel.
The animation-duration property is used to set how long the animation should sequence to complete. The time should be specified in either seconds (s) or milliseconds (ms). Set your .wheel selector to have an animation-duration property of 10s.

Set the animation property of the .cabin rule to cabins 10s linear infinite. This will set the animation-name, animation-duration, animation-timing-function, and animation-iteration-count properties in that order.

To make your cabin animation seem more like a natural swinging motion, you can use the ease-in-out timing function. This setting will tell the animation to start and end at a slower pace, but move more quickly in the middle of the cycle.

overflow: hidden;
width: 100vh;

To make the mountain look more like a mountain, you can use the skew transform function, which takes two arguments. The first being an angle to shear the x-axis by, and the second being an angle to shear the y-axis by.

Use the transform property to skew the mountain by 0deg in the x-axis and 44deg in the y-axis.

Target all descendent elements of the .penguin element, and give them a position of absolute.
.penguin *

When you activate the .penguin element, it might look as though you can drag it around. This is not true.
Indicate this to users, by giving the active element a cursor property of not-allowed.